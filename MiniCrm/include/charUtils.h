#ifndef CHARUTILS_H
#define CHARUTILS_H

#include <cstddef> // for size_t

/**
 * @brief Сравнивает две строки.
 *
 * Посимвольно сравнивает строки str1 и str2. Сравнение чувствительно к регистру
 * и учитывает ASCII-порядок символов.
 *
 * @param str1 Первая строка (nullptr приводит к неопределённому поведению).
 * @param str2 Вторая строка (nullptr приводит к неопределённому поведению).
 * @return int 0 - строки равны;
 *            отрицательное - str1 < str2;
 *            положительное - str1 > str2.
 */
int my_strcmp(const char *str1, const char *str2);

/**
 * @brief Копирует строку.
 *
 * Копирует содержимое src в dest, включая завершающий '\0'.
 * Предполагается, что dest имеет достаточный размер.
 *
 * @param dest Буфер назначения (должен вместить src + '\0').
 * @param src Исходная строка.
 * @return char* Указатель на dest.
 */
char *my_strcpy(char *dest, const char *src);

/**
 * @brief Копирует до n символов строки.
 *
 * Копирует не более n символов из src в dest. Если src короче n символов:
 * - Оставшиеся позиции заполняются '\0'
 * - Результирующая строка может не содержать '\0' (если src >=n)
 *
 * @param dest Буфер назначения (должен быть размером >=n+1).
 * @param src Исходная строка.
 * @param n Максимальное количество символов для копирования.
 * @return char* Указатель на dest.
 */
char *my_strncpy(char *dest, const char *src, size_t n);

/**
 * @brief Сравнивает первые n символов строк.
 *
 * Сравнивает до n символов или до первого несовпадения.
 * Останавливается при достижении '\0' в любой строке.
 *
 * @param str1 Первая строка.
 * @param str2 Вторая строка.
 * @param n Максимальное количество символов для сравнения.
 * @return int 0 - первые n символов совпадают;
 *            иначе разница между первыми несовпадающими символами.
 */
int my_strncmp(const char *str1, const char *str2, size_t n);

/**
 * @brief Вычисляет длину строки.
 *
 * Подсчитывает символы до первого '\0'.
 *
 * @param str Указатель на строку (nullptr приводит к неопределённому поведению).
 * @return size_t Количество символов до терминатора.
 */
size_t my_strlen(const char *str);

/**
 * @brief Проверяет, является ли символ буквой.
 *
 * Поддерживает:
 * - Латинские буквы A-Za-z
 * - Русские буквы в кодировке Windows-1251 (0xC0-0xFF)
 *
 * @param ch Проверяемый символ.
 * @return true - символ является буквой; false - иначе.
 */
bool my_isalpha(char ch);

/**
 * @brief Проверяет, является ли символ цифрой.
 *
 * Распознаёт символы '0'-'9'.
 *
 * @param ch Проверяемый символ.
 * @return true - символ цифра; false - иначе.
 */
bool my_isdigit(char ch);

/**
 * @brief Добавляет до n символов из src в конец dest.
 *
 * Добавляет символы из src в dest, начиная с конца dest.
 * Гарантирует наличие завершающего '\0'.
 *
 * @param dest Буфер назначения (должен вместить текущее содержимое + n символов + '\0').
 * @param src Исходная строка.
 * @param n Максимальное количество символов для добавления.
 * @return char* Указатель на dest.
 */
char *my_strncat(char *dest, const char *src, size_t n);

/**
 * @brief Парсит дату из строки в числовые значения.
 *
 * Ожидаемый формат: "DD MM YYYY" (разделители - пробелы).
 * Допустимые диапазоны:
 * - День: 1-31
 * - Месяц: 1-12
 * - Год: >=1
 *
 * @param data Входная строка с датой.
 * @param day Указатель для сохранения дня.
 * @param month Указатель для сохранения месяца.
 * @param year Указатель для сохранения года.
 * @return true - успешный парсинг; false - неверный формат/диапазон.
 */
bool parseDate(const char *data, int *day, int *month, int *year);

#endif